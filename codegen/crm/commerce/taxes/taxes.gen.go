// Package taxes provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package taxes

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	Oauth2Scopes = "oauth2.Scopes"
)

// Defines values for CreateTaxJSONBodyAssociationsTypesAssociationCategory.
const (
	HUBSPOTDEFINED    CreateTaxJSONBodyAssociationsTypesAssociationCategory = "HUBSPOT_DEFINED"
	INTEGRATORDEFINED CreateTaxJSONBodyAssociationsTypesAssociationCategory = "INTEGRATOR_DEFINED"
	Search            CreateTaxJSONBodyAssociationsTypesAssociationCategory = "Search"
	USERDEFINED       CreateTaxJSONBodyAssociationsTypesAssociationCategory = "USER_DEFINED"
)

// GetTaxesParams defines parameters for GetTaxes.
type GetTaxesParams struct {
	// Limit Maximum number of results per page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// After Cursor token for the next page of results.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Properties Comma-separated list of properties to include in the response.
	// If a specified property is not present, it will be ignored.
	Properties *Properties `form:"properties,omitempty" json:"properties,omitempty"`

	// PropertiesWithHistory Comma-separated list of properties to include with their historical values.
	// Historical data reduces the maximum number of objects returned per request.
	PropertiesWithHistory *PropertiesWithHistory `form:"propertiesWithHistory,omitempty" json:"propertiesWithHistory,omitempty"`

	// Associations Comma-separated list of object types to retrieve associated IDs for.
	// Nonexistent associations will be ignored.
	Associations *Associations `form:"associations,omitempty" json:"associations,omitempty"`

	// Archived Include only archived results.
	Archived *Archived `form:"archived,omitempty" json:"archived,omitempty"`
}

// CreateTaxJSONBody defines parameters for CreateTax.
type CreateTaxJSONBody struct {
	// Associations List of associations for the tax.
	Associations *[]struct {
		// To Target object details for the association.
		To *struct {
			// Id Target object ID.
			Id *string `json:"id,omitempty"`
		} `json:"to,omitempty"`
		Types *[]struct {
			// AssociationCategory Category of the association.
			AssociationCategory *CreateTaxJSONBodyAssociationsTypesAssociationCategory `json:"associationCategory,omitempty"`

			// AssociationTypeId ID of the association type.
			AssociationTypeId *int32 `json:"associationTypeId,omitempty"`
		} `json:"types,omitempty"`
	} `json:"associations,omitempty"`

	// ObjectWriteTraceId Trace ID for object write operations.
	ObjectWriteTraceId *string `json:"objectWriteTraceId,omitempty"`

	// Properties Key-value pairs of tax properties.
	Properties map[string]string `json:"properties"`
}

// CreateTaxJSONBodyAssociationsTypesAssociationCategory defines parameters for CreateTax.
type CreateTaxJSONBodyAssociationsTypesAssociationCategory string

// SearchTaxesJSONBody defines parameters for SearchTaxes.
type SearchTaxesJSONBody struct {
	After        *string        `json:"after,omitempty"`
	FilterGroups []FilterGroups `json:"filterGroups,omitempty"`
	Limit        *int           `json:"limit,omitempty"`
	Properties   *[]string      `json:"properties,omitempty"`
	Query        *string        `json:"query,omitempty"`
	Sorts        *[]string      `json:"sorts,omitempty"`
}

// GetTaxByIdParams defines parameters for GetTaxById.
type GetTaxByIdParams struct {
	// IdProperty The property to use as the ID.
	IdProperty *string `form:"idProperty,omitempty" json:"idProperty,omitempty"`

	// Properties Comma-separated list of properties to include in the response.
	// If a specified property is not present, it will be ignored.
	Properties *Properties `form:"properties,omitempty" json:"properties,omitempty"`

	// PropertiesWithHistory Comma-separated list of properties to include with their historical values.
	// Historical data reduces the maximum number of objects returned per request.
	PropertiesWithHistory *PropertiesWithHistory `form:"propertiesWithHistory,omitempty" json:"propertiesWithHistory,omitempty"`

	// Associations Comma-separated list of object types to retrieve associated IDs for.
	// Nonexistent associations will be ignored.
	Associations *Associations `form:"associations,omitempty" json:"associations,omitempty"`

	// Archived Include only archived results.
	Archived *Archived `form:"archived,omitempty" json:"archived,omitempty"`
}

// UpdateTaxJSONBody defines parameters for UpdateTax.
type UpdateTaxJSONBody struct {
	// ObjectWriteTraceId Unique trace ID for the operation.
	ObjectWriteTraceId *string `json:"objectWriteTraceId,omitempty"`

	// Properties Key-value pairs representing the deal properties to update.
	Properties map[string]string `json:"properties"`
}

// CreateTaxJSONRequestBody defines body for CreateTax for application/json ContentType.
type CreateTaxJSONRequestBody CreateTaxJSONBody

// SearchTaxesJSONRequestBody defines body for SearchTaxes for application/json ContentType.
type SearchTaxesJSONRequestBody SearchTaxesJSONBody

// UpdateTaxJSONRequestBody defines body for UpdateTax for application/json ContentType.
type UpdateTaxJSONRequestBody UpdateTaxJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Retrieve a list of taxes
	// (GET /crm/v3/objects/taxes)
	GetTaxes(ctx echo.Context, params GetTaxesParams) error
	// Create a new tax
	// (POST /crm/v3/objects/taxes)
	CreateTax(ctx echo.Context) error
	// Search for taxes by email
	// (POST /crm/v3/objects/taxes/search)
	SearchTaxes(ctx echo.Context) error
	// Delete a tax
	// (DELETE /crm/v3/objects/taxes/{taxId})
	DeleteTaxById(ctx echo.Context, taxId string) error
	// Get Tax Details
	// (GET /crm/v3/objects/taxes/{taxId})
	GetTaxById(ctx echo.Context, taxId int64, params GetTaxByIdParams) error
	// Update a tax
	// (PATCH /crm/v3/objects/taxes/{taxId})
	UpdateTax(ctx echo.Context, taxId string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetTaxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetTaxes(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"crm.objects.taxes.write", "crm.schemas.taxes.write", "crm.objects.taxes.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTaxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// ------------- Optional query parameter "properties" -------------

	err = runtime.BindQueryParameter("form", false, false, "properties", ctx.QueryParams(), &params.Properties)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter properties: %s", err))
	}

	// ------------- Optional query parameter "propertiesWithHistory" -------------

	err = runtime.BindQueryParameter("form", false, false, "propertiesWithHistory", ctx.QueryParams(), &params.PropertiesWithHistory)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter propertiesWithHistory: %s", err))
	}

	// ------------- Optional query parameter "associations" -------------

	err = runtime.BindQueryParameter("form", false, false, "associations", ctx.QueryParams(), &params.Associations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter associations: %s", err))
	}

	// ------------- Optional query parameter "archived" -------------

	err = runtime.BindQueryParameter("form", true, false, "archived", ctx.QueryParams(), &params.Archived)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archived: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTaxes(ctx, params)
	return err
}

// CreateTax converts echo context to params.
func (w *ServerInterfaceWrapper) CreateTax(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"crm.objects.taxes.write", "crm.schemas.taxes.write", "crm.objects.taxes.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateTax(ctx)
	return err
}

// SearchTaxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchTaxes(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"crm.objects.taxes.write", "crm.schemas.taxes.write", "crm.objects.taxes.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchTaxes(ctx)
	return err
}

// DeleteTaxById converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTaxById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "taxId" -------------
	var taxId string

	err = runtime.BindStyledParameterWithOptions("simple", "taxId", ctx.Param("taxId"), &taxId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter taxId: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"crm.objects.taxes.write", "crm.schemas.taxes.write", "crm.objects.taxes.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteTaxById(ctx, taxId)
	return err
}

// GetTaxById converts echo context to params.
func (w *ServerInterfaceWrapper) GetTaxById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "taxId" -------------
	var taxId int64

	err = runtime.BindStyledParameterWithOptions("simple", "taxId", ctx.Param("taxId"), &taxId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter taxId: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"crm.objects.taxes.write", "crm.schemas.taxes.write", "crm.objects.taxes.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTaxByIdParams
	// ------------- Optional query parameter "idProperty" -------------

	err = runtime.BindQueryParameter("form", true, false, "idProperty", ctx.QueryParams(), &params.IdProperty)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter idProperty: %s", err))
	}

	// ------------- Optional query parameter "properties" -------------

	err = runtime.BindQueryParameter("form", false, false, "properties", ctx.QueryParams(), &params.Properties)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter properties: %s", err))
	}

	// ------------- Optional query parameter "propertiesWithHistory" -------------

	err = runtime.BindQueryParameter("form", false, false, "propertiesWithHistory", ctx.QueryParams(), &params.PropertiesWithHistory)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter propertiesWithHistory: %s", err))
	}

	// ------------- Optional query parameter "associations" -------------

	err = runtime.BindQueryParameter("form", false, false, "associations", ctx.QueryParams(), &params.Associations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter associations: %s", err))
	}

	// ------------- Optional query parameter "archived" -------------

	err = runtime.BindQueryParameter("form", true, false, "archived", ctx.QueryParams(), &params.Archived)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archived: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTaxById(ctx, taxId, params)
	return err
}

// UpdateTax converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateTax(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "taxId" -------------
	var taxId string

	err = runtime.BindStyledParameterWithOptions("simple", "taxId", ctx.Param("taxId"), &taxId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter taxId: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"crm.objects.taxes.write", "crm.schemas.taxes.write", "crm.objects.taxes.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateTax(ctx, taxId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/crm/v3/objects/taxes", wrapper.GetTaxes)
	router.POST(baseURL+"/crm/v3/objects/taxes", wrapper.CreateTax)
	router.POST(baseURL+"/crm/v3/objects/taxes/search", wrapper.SearchTaxes)
	router.DELETE(baseURL+"/crm/v3/objects/taxes/:taxId", wrapper.DeleteTaxById)
	router.GET(baseURL+"/crm/v3/objects/taxes/:taxId", wrapper.GetTaxById)
	router.PATCH(baseURL+"/crm/v3/objects/taxes/:taxId", wrapper.UpdateTax)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"NAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
