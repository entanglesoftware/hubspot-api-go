// Package orders provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package orders

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	Oauth2Scopes = "oauth2.Scopes"
)

// GetOrdersParams defines parameters for GetOrders.
type GetOrdersParams struct {
	// Limit Maximum number of results per page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// After Cursor token for the next page of results.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Properties Comma-separated list of properties to include in the response.
	// If a specified property is not present, it will be ignored.
	Properties *Properties `form:"properties,omitempty" json:"properties,omitempty"`

	// PropertiesWithHistory Comma-separated list of properties to include with their historical values.
	// Historical data reduces the maximum number of objects returned per request.
	PropertiesWithHistory *PropertiesWithHistory `form:"propertiesWithHistory,omitempty" json:"propertiesWithHistory,omitempty"`

	// Associations Comma-separated list of object types to retrieve associated IDs for.
	// Nonexistent associations will be ignored.
	Associations *Associations `form:"associations,omitempty" json:"associations,omitempty"`

	// Archived Include only archived results.
	Archived *Archived `form:"archived,omitempty" json:"archived,omitempty"`
}

// CreateOrderJSONBody defines parameters for CreateOrder.
type CreateOrderJSONBody struct {
	Associations       *[]OrderAssociationRequest `json:"associations,omitempty"`
	ObjectWriteTraceId *string                    `json:"objectWriteTraceId,omitempty"`
	Properties         map[string]string          `json:"properties"`
}

// SearchOrdersJSONBody defines parameters for SearchOrders.
type SearchOrdersJSONBody struct {
	After        *string        `json:"after,omitempty"`
	FilterGroups []FilterGroups `json:"filterGroups,omitempty"`
	Limit        *int           `json:"limit,omitempty"`
	Properties   *[]string      `json:"properties,omitempty"`
	Query        *string        `json:"query,omitempty"`
	Sorts        *[]string      `json:"sorts,omitempty"`
}

// GetOrderByIdParams defines parameters for GetOrderById.
type GetOrderByIdParams struct {
	// IdProperty The property to use as the ID.
	IdProperty *string `form:"idProperty,omitempty" json:"idProperty,omitempty"`

	// Properties Comma-separated list of properties to include in the response.
	// If a specified property is not present, it will be ignored.
	Properties *Properties `form:"properties,omitempty" json:"properties,omitempty"`

	// PropertiesWithHistory Comma-separated list of properties to include with their historical values.
	// Historical data reduces the maximum number of objects returned per request.
	PropertiesWithHistory *PropertiesWithHistory `form:"propertiesWithHistory,omitempty" json:"propertiesWithHistory,omitempty"`

	// Associations Comma-separated list of object types to retrieve associated IDs for.
	// Nonexistent associations will be ignored.
	Associations *Associations `form:"associations,omitempty" json:"associations,omitempty"`

	// Archived Include only archived results.
	Archived *Archived `form:"archived,omitempty" json:"archived,omitempty"`
}

// UpdateOrderJSONBody defines parameters for UpdateOrder.
type UpdateOrderJSONBody struct {
	// ObjectWriteTraceId Unique trace ID for the operation.
	ObjectWriteTraceId *string `json:"objectWriteTraceId,omitempty"`

	// Properties Key-value pairs representing the deal properties to update.
	Properties map[string]string `json:"properties"`
}

// CreateOrderJSONRequestBody defines body for CreateOrder for application/json ContentType.
type CreateOrderJSONRequestBody CreateOrderJSONBody

// SearchOrdersJSONRequestBody defines body for SearchOrders for application/json ContentType.
type SearchOrdersJSONRequestBody SearchOrdersJSONBody

// UpdateOrderJSONRequestBody defines body for UpdateOrder for application/json ContentType.
type UpdateOrderJSONRequestBody UpdateOrderJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Retrieve a list of orders
	// (GET /crm/v3/objects/orders)
	GetOrders(ctx echo.Context, params GetOrdersParams) error
	// Create a new order
	// (POST /crm/v3/objects/orders)
	CreateOrder(ctx echo.Context) error
	// Search for orders by email
	// (POST /crm/v3/objects/orders/search)
	SearchOrders(ctx echo.Context) error
	// Delete a order
	// (DELETE /crm/v3/objects/orders/{orderId})
	DeleteOrderById(ctx echo.Context, orderId string) error
	// Get Order Details
	// (GET /crm/v3/objects/orders/{orderId})
	GetOrderById(ctx echo.Context, orderId int64, params GetOrderByIdParams) error
	// Update a order
	// (PATCH /crm/v3/objects/orders/{orderId})
	UpdateOrder(ctx echo.Context, orderId string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetOrders converts echo context to params.
func (w *ServerInterfaceWrapper) GetOrders(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"crm.objects.orders.write", "crm.objects.orders.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOrdersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// ------------- Optional query parameter "properties" -------------

	err = runtime.BindQueryParameter("form", false, false, "properties", ctx.QueryParams(), &params.Properties)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter properties: %s", err))
	}

	// ------------- Optional query parameter "propertiesWithHistory" -------------

	err = runtime.BindQueryParameter("form", false, false, "propertiesWithHistory", ctx.QueryParams(), &params.PropertiesWithHistory)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter propertiesWithHistory: %s", err))
	}

	// ------------- Optional query parameter "associations" -------------

	err = runtime.BindQueryParameter("form", false, false, "associations", ctx.QueryParams(), &params.Associations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter associations: %s", err))
	}

	// ------------- Optional query parameter "archived" -------------

	err = runtime.BindQueryParameter("form", true, false, "archived", ctx.QueryParams(), &params.Archived)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archived: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOrders(ctx, params)
	return err
}

// CreateOrder converts echo context to params.
func (w *ServerInterfaceWrapper) CreateOrder(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"crm.objects.orders.write", "crm.objects.orders.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateOrder(ctx)
	return err
}

// SearchOrders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchOrders(ctx echo.Context) error {
	var err error

	ctx.Set(Oauth2Scopes, []string{"crm.objects.orders.write", "crm.objects.orders.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchOrders(ctx)
	return err
}

// DeleteOrderById converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteOrderById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "orderId" -------------
	var orderId string

	err = runtime.BindStyledParameterWithOptions("simple", "orderId", ctx.Param("orderId"), &orderId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderId: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"crm.objects.orders.write", "crm.objects.orders.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteOrderById(ctx, orderId)
	return err
}

// GetOrderById converts echo context to params.
func (w *ServerInterfaceWrapper) GetOrderById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "orderId" -------------
	var orderId int64

	err = runtime.BindStyledParameterWithOptions("simple", "orderId", ctx.Param("orderId"), &orderId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderId: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"crm.objects.orders.write", "crm.objects.orders.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOrderByIdParams
	// ------------- Optional query parameter "idProperty" -------------

	err = runtime.BindQueryParameter("form", true, false, "idProperty", ctx.QueryParams(), &params.IdProperty)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter idProperty: %s", err))
	}

	// ------------- Optional query parameter "properties" -------------

	err = runtime.BindQueryParameter("form", false, false, "properties", ctx.QueryParams(), &params.Properties)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter properties: %s", err))
	}

	// ------------- Optional query parameter "propertiesWithHistory" -------------

	err = runtime.BindQueryParameter("form", false, false, "propertiesWithHistory", ctx.QueryParams(), &params.PropertiesWithHistory)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter propertiesWithHistory: %s", err))
	}

	// ------------- Optional query parameter "associations" -------------

	err = runtime.BindQueryParameter("form", false, false, "associations", ctx.QueryParams(), &params.Associations)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter associations: %s", err))
	}

	// ------------- Optional query parameter "archived" -------------

	err = runtime.BindQueryParameter("form", true, false, "archived", ctx.QueryParams(), &params.Archived)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archived: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOrderById(ctx, orderId, params)
	return err
}

// UpdateOrder converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateOrder(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "orderId" -------------
	var orderId string

	err = runtime.BindStyledParameterWithOptions("simple", "orderId", ctx.Param("orderId"), &orderId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter orderId: %s", err))
	}

	ctx.Set(Oauth2Scopes, []string{"crm.objects.orders.write", "crm.objects.orders.read"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateOrder(ctx, orderId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/crm/v3/objects/orders", wrapper.GetOrders)
	router.POST(baseURL+"/crm/v3/objects/orders", wrapper.CreateOrder)
	router.POST(baseURL+"/crm/v3/objects/orders/search", wrapper.SearchOrders)
	router.DELETE(baseURL+"/crm/v3/objects/orders/:orderId", wrapper.DeleteOrderById)
	router.GET(baseURL+"/crm/v3/objects/orders/:orderId", wrapper.GetOrderById)
	router.PATCH(baseURL+"/crm/v3/objects/orders/:orderId", wrapper.UpdateOrder)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
